name: Release default
on:
  workflow_dispatch:
    inputs:
      main_checkmark:
        description: 'Build from main branches'
        default: false
        type: boolean
        required: true
      release_version:
        description: 'Enter the release version (e.g. v1.2.3)'
        required: true

jobs:
  release:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout origin (ci-cd-main) repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Ensures all branches and history are fetched

      - name: Set up branches based on checkmark input
        id: set_branches
        run: |
          echo "Validating checkmark set"
          if [ "${{ github.event.inputs.main_checkmark }}" == "true" ]; then
            echo "Building from main branches"
            echo "CLIENT1_BRANCH=main" >> $GITHUB_ENV
            echo "CLIENT2_BRANCH=main" >> $GITHUB_ENV
            echo "RELEASE_BRANCH=main" >> $GITHUB_ENV
          else
            echo "Error: checkmark was not set"
            exit 1
          fi

      - name: Checkout submodule client1
        uses: actions/checkout@v4
        with:
          token: '${{ secrets.GITHUB_TOKEN }}'
          repository: illyazhuk/client1
          path: default/procentric/app/client1
          ref: ${{ env.CLIENT1_BRANCH }}

      - name: Checkout submodule client2
        uses: actions/checkout@v4
        with:
          token: '${{ secrets.GITHUB_TOKEN }}'
          repository: illyazhuk/client2
          path: default/remote/client2
          ref: ${{ env.CLIENT2_BRANCH }}

      - name: Checkout to a new branch
        run: |
          echo "Configuring branch on origin repository"
          if [[ "${{ env.RELEASE_BRANCH }}" == "main" ]] || [[ "${{ env.RELEASE_BRANCH }}" == "master" ]]; then
            echo "Skip checkout for main/master branch"

          elif git ls-remote --heads origin "${{ env.RELEASE_BRANCH }}" | grep -q "${{ env.RELEASE_BRANCH }}"; then
            echo "Error: ${{ env.RELEASE_BRANCH }} already exists on Remote"
            exit 1

          else
            echo "Switching to a new branch ${{ env.RELEASE_BRANCH }}"
            git checkout -b ${{ env.RELEASE_BRANCH }}
          fi

      - name: Commit updated submodule pointers
        run: |
          echo "Configuring user for a commit"
          git config --global user.email "actions@github.com"
          git config --global user.name "GitHub Actions"
          echo "Check difference in submodule pointers"
          git diff
          echo "Adding updated code"
          git add .
          echo "Creating commit with updates for submodules"
          git diff-index --quiet HEAD || git commit -m "Update submodules to latest branches"

      - name: manage-release-version
        run: |
            USER_VERSION_VALID=false
            # Get the release version from the input
            RELEASE_VERSION="${{ github.event.inputs.release_version }}"
            echo "Validate release version compliance"
    
            # Validate the version format (e.g. v1.2.3)
            if [[ ! "$RELEASE_VERSION" =~ ^v?[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
                echo "Error: Invalid version format. The version should be in the format (e.g. v1.2.3)"
                #exit 1 # Uncomment this if you want to terminate when the version is invalid
            else
                USER_VERSION_VALID=true
            fi

            echo "Fetching latest tag from repo"
            # Fetch all tags to ensure the latest tags are available locally
            git fetch --tags

            # Get the latest tag from the repository by sorting tags
            LATEST_TAG=$(git tag --sort=-v:refname | head -n 1)

            # Get the latest tag from the repository
            #LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "none")
            echo "Found Latest Tag on repository $LATEST_TAG"

            if [ "$LATEST_TAG" = "none" ]; then
                echo "Warning: No tags found in the repository."
                LATEST_TAG="0.0.0"  # Set a default version if needed
            fi

            # Check if user version is greater than latest tag
            if [[ "$(echo -e "$RELEASE_VERSION\n$LATEST_TAG" | sort -V | head -n1)" == "$RELEASE_VERSION" && "$USER_VERSION_VALID" == true ]]; then
                echo "Error: Release version $RELEASE_VERSION must be higher than the latest tag $LATEST_TAG."
                USER_VERSION_VALID=false
            fi
    
            # If user input is valid, use the user version; otherwise, auto-increment
            if [ "$USER_VERSION_VALID" = true ]; then
                NEW_VERSION="$RELEASE_VERSION"
            else
                echo "Extracting major, minor, patch from the latest tag $LATEST_TAG"
                VERSION_PATTERN="^v?([0-9]+)\.([0-9]+)\.([0-9]+)$"
                if [[ "$LATEST_TAG" =~ $VERSION_PATTERN ]]; then
                    MAJOR="${BASH_REMATCH[1]}"
                    MINOR="${BASH_REMATCH[2]}"
                    PATCH="${BASH_REMATCH[3]}"
                    PATCH=$((PATCH + 1))  # Increment the patch version
                    NEW_VERSION="$MAJOR.$MINOR.$PATCH"
                else
                    NEW_VERSION="0.0.1"
                fi
            fi

            # If no tags are found, set a default version
            if [ -z "$LATEST_TAG" ]; then
                echo "No tags found in the repository. This will be the first release."
            else
                # Compare versions
                if [[ "$(echo -e "$NEW_VERSION\n$LATEST_TAG" | sort -V | head -n1)" == "$NEW_VERSION" ]]; then
                    echo "Error: Release version $NEW_VERSION must be higher than the latest tag $LATEST_TAG."
                    exit 1
                else
                    echo "Release version $NEW_VERSION is valid and higher than the latest tag $LATEST_TAG."
                fi
            fi
    
            # Output the new release version to the GitHub environment for later steps
            echo "RELEASE_TAG=$NEW_VERSION" >> $GITHUB_ENV


      - name: Push changes to target branch
        run: |
            echo "Validating possibility to push changes to target branch"
            if [[ "${{ env.RELEASE_BRANCH }}" == "main" ]] || [[ "${{ env.RELEASE_BRANCH }}" == "master" ]]; then
              echo "Target branch is main - Push updated state"
              git push
    
            else
              echo "Ensure target branch would not be overwritten"
              if git ls-remote --heads origin "${{ env.RELEASE_BRANCH }}" | grep -q "${{ env.RELEASE_BRANCH }}"; then
                echo "Branch already exists on remote, not pushing."
                exit 1
    
              else
                  echo "Create upstream to a new target branch"
                  git push --set-upstream origin ${{ env.RELEASE_BRANCH }}
              fi
            fi
    
      - name: Create and push release tag
        run: |
            echo "Configuring release tag"
            if [[ "${{ env.RELEASE_BRANCH }}" == "main" ]] || [[ "${{ env.RELEASE_BRANCH }}" == "master" ]]; then
                echo "Target branch is main - create a release tag"
                git tag -a "env.RELEASE_TAG" -m "Release $RELEASE_TAG"
                git push origin "$RELEASE_TAG"
            else
                echo "Custom target branch - release tag is not allowed"
            fi
          
      - name: Automate pull request
        uses: peter-evans/create-pull-request@v7
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
